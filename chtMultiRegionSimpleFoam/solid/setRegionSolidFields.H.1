
    fvMesh& mesh = solidRegions[i];
    solidThermo& thermo = thermos[i];
    const radiation::radiationModel& radiation = radiations[i];

    tmp<volScalarField> trho = thermo.rho();
    const volScalarField& rho = trho();

    tmp<volScalarField> tcp = thermo.Cp();
    const volScalarField& cp = tcp();

    tmp<volScalarField> talpha = thermo.alpha();
    const volScalarField& alpha = talpha();
    tmp<volScalarField> tkappa = thermo.kappa();
    const volScalarField& kappa = tkappa();

    volScalarField& h = thermo.he();

    const volScalarField& betav = betavSolid[i];

//    fv::IOoptionList& fvOptions = solidHeatSources[i];

    // Added to use my source-term
    // When reading from another file, it should be done at
    // this point, before atributing the qVol to const Q field

    // 22/05/2014
    // In this point, the external Q field will be read.
    // The solver will wait for the file in the comm directory.
    // Basically, it will try to read the IOobject representing
    // We're inside the runtime loop at this point. So, we try to read
    // the object and if it is present, we use it. If the time is too long
    // we abort or calculate with the current Q.
    // --------------------------------------------------------------------
    // THIS APPROACH MUST be checked in the future
    // Read Q if it exists. If not, create a null (zero)
    // volScalarField

    ////////////////////////////////////////////////////////////////////////
    // File Q.lock and Q.data must be read by only one process (or master)
    // after Q.data is read, then the code can be parallelized
    // ---------------------------------------------------------------------
    // READING: check if lock is present. If it is, read the IOobject
    //          and use new Q values
    // Do not creat file before hand because it's necessary to check if
    // it exists before.

    // First of all, only do that if the solid is the fuel
    if (solidRegions[i].name() == "fuel")
    {
    	if(fstream(strLockFilePath.c_str()))
    	{
    		// File exists
    		Info << " ------------- ADDED: readLockFile exists." << endl;
    		// Wait... or keep running?
    	}
    	else
    	{
    		// A better option is read the "crude" file and change only the
    		// VolScalarField internalField() before creating const VolScalarField& Q.
    		Info << " ------------- ADDED: readLock não existe ou não encontrado." << endl;

    		// Create lockFile
//    		ofstream lockFile(strLockFilePath.c_str());
//    		if(!lockFile)
//    			FatalErrorIn("Error when creating lock file. Exiting...") << "" << exit(FatalError);
    		if(Pstream::master())
    		{
/*
 * Only if decide to read a complete Q file.
    			IOobject Qfile
    			(
    				"Q.data",
    				strLockFilePath.c_str(),
    				solidRegions[i],
    				IOobject::MUST_READ,
    				IOobject::NO_WRITE
    			);
*/

    		}

    		// ----------------------------------------------------------------------------
    		// This code is only valid if coupling with a complete OpenFOAM field file.
    		// What means the boundaries and all header information must be read from Q.data
    		//
    		// It's here only for consideration since the coupling will be made as a simple file:
    		// First line: field size and next lines the field values. Size of Q.data file
    		// is "fieldSize + 1"

    		// At this point, Q is zero if the file does not exist
    		// or is filled with values from file "Q"
    		// Must check it before creating the field
    		if(Qfile.headerOk())
    		{
    	   		Info << " ------------- ADDED: Qfile.headerOk..." << endl;

    	   		// Create a qvol field from dictionary
    			qVol.set
    			(
    					i,
    					new volScalarField (Qfile, solidRegions[i])
    			);

    	   		Info << " ------------- ADDED: qVol created..." << endl;
    	   		Info << " ------------- ADDED: volScalarField size: " << qVol[i].size() << endl;

    			// Write a scalarField over the internalField of volScalarField
//    			qVol[i].internalField()=scalar(44444.4); // funciona. ver como atribuir o campo

    			// Create a scalar field from the values read from Q.data
    			scalarField sF = scalarField(qVol[i].size());

    			Info << " ------------- ADDED: Sf criado..." << endl;
    			std::vector <float> v;
    			v.assign(qVol[i].size(), 100000);

    	   		std:cout << " ------------- ADDED: vector v size: " << v.size() << std::endl;

    			Info << " ------------- ADDED: (1) Sf: " << sF << " size: " << sF.size() << endl;

    			forAll(sF, j)
    			{
    				sF[j] = v.at(j)+j;
    			}

    			Info << " ------------- ADDED: (2) Sf: " << sF << " size: " << sF.size() << endl;
    			qVol[i].internalField()= sF;

    			// Remove the file calling remove() from <cstdio>
    			if(remove("/home/vitors/workspace/tutorials/acople1/comms/Q.data")== -1)
    				FatalErrorIn("File Q.data not erased.") << "" << exit(FatalError);
    		}
    	}
     }


    // If the file is not present, use current qVol[i] (the volScalarField)
    const volScalarField& Q = qVol[i];
//  volScalarField& Q = qVol[i];
